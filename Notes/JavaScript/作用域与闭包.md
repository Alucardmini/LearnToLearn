# 你不知道的Javascript学习笔记（一）——作用域与闭包

## 作用域相关
1. 变量的赋值操作:  
首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会查找该变量，如果能找到就对他赋值。

2. 声明的提前  
编译器可以在代码生成的同时处理声明和值的定义。

3. LHS & RHS
变量出现在赋值操作的左侧时进行LHS，出现在非左侧，为了得到源值所进行的查询为RHS.
不成功的RHS引用会导致抛出ReferenceError异常，不成功LHS引用会导致在非严格模式下自动隐式地创建一个全局变量。

4.  异常类型
ReferenceError同作用域判别失败相关。
TypeError表示作用域判别成功，但对结果的操作是非法或不合理的。

5.  遮蔽效应
在多层嵌套的作用域中定义同名标识符，内部的会遮蔽外部的。作用域查找会在找到第一个匹配的标识符时停止。

5. 库
通常会在全局作用域中声明一个名字足够独特的变量（对象），作为命名空间，其功能以对象的属性的方式暴露给外界。

6. 模块管理
通过依赖管理器的机制将库的标识符显式地导入到另外一个作用域中。

## 词法与块级作用域
1. 词法作用域
意味着作用域是由书写代码时函数声明的位置决定的，编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对他们进行查找。
with和eval能够欺骗词法作用域，导致性能下降，所以不要使用他们。

2. 块级作用域
- catch，let，const会创建一个块级作用域.
- let进行的声明，不会在块级作用域内进行提升。
- const创建了具有块级作用域的常数。

## 函数相关
1. 函数作用域
属于函数的全部变量都可以在整个函数范围内使用及复用。
软件设计中，应最小限度地暴露必要内容，将其他内容隐藏起来，通过作用域可以实现隐藏一些变量在作用域内部。

2. 函数声明和函数表达式
如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

3. 匿名的函数表达式
当函数需要引用自身时，只能使用arguments.callee（规范中已经不建议使用）。始终给函数表达式命名是一个最佳实践。

4. IIFE
立即执行函数表达式，使用具名的IIFE是一个值得推广的实践。

## 闭包
> **当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。**

**理解**：实际上我们是想在一个变量的作用域外访问该变量，这时候只需要在该作用域声明一个函数，用该函数访问想要访问的那个变量，由于作用域链的延伸，这是可以实现的。然后在该作用域内把这个函数作为返回值，这样就实现了从作用域外部访问作用域内的变量的目的。这个实现过程就叫做闭包。

以下两个代码块可以实现相同的功能，其实质解决的是javascrit本身的for循环不存在块级作用域的问题。setTimeout在for循环里声明了回调函数，在for循环结束后执行这些回调函数，而有了块级作用域后，每次回调都被关闭在了作用域内，也就能访问当前的i的值。
~~~
//使用let实现块级作用域
for(let i=1;i<5;i++){
    setTimeout(function timer(){
        console.log(i);
        },i*1000);
}
//使用IIFE实现块级作用域
for(var i=1;i<5;i++){
    (function(j){
        setTimeout(function timer(){
            console.log(j);
            },j*1000);
        })(i);
}
~~~

## 模块
两个必要条件：
1. 必须有外部的封闭函数，该函数必须至少被调用一次（通过IIFE单次调用，或者通过var赋值多次调用），每次调用会创建一个新的模块实例。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或修改私有的状态。